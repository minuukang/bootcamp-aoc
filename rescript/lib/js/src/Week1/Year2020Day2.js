// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Process = require("process");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function parsePasswordRule(str) {
  var parts = str.split(" ");
  var rangeInt = Belt_Option.mapWithDefault(Belt_Array.get(parts, 0), [], (function (range) {
          return Belt_Array.map(range.split("-"), Belt_Int.fromString);
        }));
  var required = Belt_Option.mapWithDefault(Belt_Array.get(parts, 1), undefined, (function (rule) {
          return Belt_Array.get(rule.split(":"), 0);
        }));
  var password = Belt_Array.get(parts, 2);
  var min = Belt_Array.get(rangeInt, 0);
  var max = Belt_Array.get(rangeInt, 1);
  if (min === undefined) {
    return {
            TAG: /* Error */1,
            _0: "Invalid password rule"
          };
  }
  var min$1 = Caml_option.valFromOption(min);
  if (min$1 === undefined) {
    return {
            TAG: /* Error */1,
            _0: "Invalid password rule"
          };
  }
  if (max === undefined) {
    return {
            TAG: /* Error */1,
            _0: "Invalid password rule"
          };
  }
  var max$1 = Caml_option.valFromOption(max);
  if (max$1 !== undefined && required !== undefined && password !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: {
              min: min$1,
              max: max$1,
              required: required,
              password: password
            }
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: "Invalid password rule"
          };
  }
}

function validatePasswordOldRule(rule) {
  var required = rule.required;
  var sizeOfRequired = Belt_Array.keep(rule.password.split(""), (function ($$char) {
          return $$char === required;
        })).length;
  if (sizeOfRequired >= rule.min) {
    return sizeOfRequired <= rule.max;
  } else {
    return false;
  }
}

function validatePasswordNewRule(rule) {
  var password = rule.password;
  var required = rule.required;
  var matchMinRequired = password.charAt(rule.min - 1 | 0) === required;
  var matchMaxRequired = password.charAt(rule.max - 1 | 0) === required;
  if (matchMinRequired || matchMaxRequired) {
    return !(matchMinRequired && matchMaxRequired);
  } else {
    return false;
  }
}

var input = Fs.readFileSync(Process.cwd() + "/rescript/input/Week1/Year2020Day2.input.txt", "utf8");

var passwordRules = Belt_Array.keepMap(Belt_Array.map(input.split("\n"), parsePasswordRule), (function (result) {
        if (result.TAG === /* Ok */0) {
          return result._0;
        }
        
      }));

var stepOneAnswer = Belt_Array.keep(passwordRules, validatePasswordOldRule).length;

var stepTwoAnswer = Belt_Array.keep(passwordRules, validatePasswordNewRule).length;

console.log({
      stepOneAnswer: stepOneAnswer,
      stepTwoAnswer: stepTwoAnswer
    });

exports.parsePasswordRule = parsePasswordRule;
exports.validatePasswordOldRule = validatePasswordOldRule;
exports.validatePasswordNewRule = validatePasswordNewRule;
exports.input = input;
exports.passwordRules = passwordRules;
exports.stepOneAnswer = stepOneAnswer;
exports.stepTwoAnswer = stepTwoAnswer;
/* input Not a pure module */
